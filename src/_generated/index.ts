/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Fincra Converter
 * Convert your currency
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { faker } from '@faker-js/faker';
import { HttpResponse, delay, http } from 'msw';
import { customInstance } from '../lib/axios';
export type GetDashboardData200 = {
  /** @nullable */
  data: DashboardEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type GetManyTransactions200 = {
  /** @nullable */
  data: TransactionEntity[] | null;
  /** A descriptive message about the result */
  message: string;
  /** Pagination metadata */
  meta?: PaginationMeta;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type GetManyTransactionsSortDirection =
  (typeof GetManyTransactionsSortDirection)[keyof typeof GetManyTransactionsSortDirection];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetManyTransactionsSortDirection = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type GetManyTransactionsParams = {
  status?: TransactionStatus;
  sortBy?: TransactionSortBy;
  startDate?: string;
  endDate?: string;
  sortDirection?: GetManyTransactionsSortDirection;
  fields?: string;
  page?: number;
  perPage?: number;
  reference?: string;
};

export type RequeryTransaction200 = {
  /** @nullable */
  data: TransactionEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type ConvertFunds201 = {
  /** @nullable */
  data: TransactionEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type FundAccount200 = {
  /** @nullable */
  data: AccountEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type VerifyPasswordResetToken200 = {
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type ResendConfirmEmail200 = {
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type ResetPassword200 = {
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type ForgotPassword200 = {
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type ConfirmAccount200 = {
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type GetUserAbilities200 = {
  /** @nullable */
  data: string[] | null;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type GetProfile200 = {
  /** @nullable */
  data: UserEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type RefreshToken200 = {
  /** @nullable */
  data: UserEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type StopImpersonation200 = {
  /** @nullable */
  data: UserEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type ImpersonateUser200 = {
  /** @nullable */
  data: UserEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type Login200 = {
  /** @nullable */
  data: UserEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type Signup201 = {
  /** @nullable */
  data: UserEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export interface DashboardEntity {
  /** */
  balances: AccountEntity[];
  /** */
  recentTransactions: TransactionEntity[];
}

export type TransactionSortBy =
  (typeof TransactionSortBy)[keyof typeof TransactionSortBy];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionSortBy = {
  id: 'id',
  reference: 'reference',
  userId: 'userId',
  fromCurrency: 'fromCurrency',
  toCurrency: 'toCurrency',
  conversionRate: 'conversionRate',
  originalAmount: 'originalAmount',
  convertedAmount: 'convertedAmount',
  status: 'status',
  fromAccountId: 'fromAccountId',
  toAccountId: 'toAccountId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
} as const;

export interface PaginationMeta {
  /** Current page number */
  currentPage: number;
  /** last page number */
  lastPage: number;
  /**
   * Next page number. Value will be null if at last page
   * @nullable
   */
  next: number | null;
  /** Number of items requested per page */
  perPage: number;
  /**
   * Previous page number. Value will be null if at first page
   * @nullable
   */
  prev: number | null;
  /** total number of items matching query */
  total: number;
}

export interface ConvertFundsDto {
  amount: string;
  fromAccountId: string;
  toAccountId: string;
}

export type TransactionStatus =
  (typeof TransactionStatus)[keyof typeof TransactionStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionStatus = {
  Pending: 'Pending',
  Processing: 'Processing',
  Completed: 'Completed',
  Failed: 'Failed',
  Reversed: 'Reversed',
} as const;

export interface TransactionEntity {
  conversionRate: string;
  convertedAmount: string;
  createdAt: string;
  fromAccountId: string;
  fromCurrency: string;
  id: number;
  originalAmount: string;
  reference: string;
  status: TransactionStatus;
  toAccountId: string;
  toCurrency: string;
  updatedAt: string;
  userId: number;
}

export interface FundOrWithdrawFromAccountDto {
  amount: string;
}

/**
 * @nullable
 */
export type AccountEntityUser = UserEntity | null;

export interface AccountEntity {
  availableBalance: string;
  currencyCode: string;
  currencyName: string;
  currencySymbol: string;
  id: string;
  /** @nullable */
  info?: AccountEntityInfo;
  pendingBalance: string;
  /** @nullable */
  user?: AccountEntityUser;
  userId: number;
}

export type GetUserAccountById200 = {
  /** @nullable */
  data: AccountEntity;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

export type GetUserAccounts200 = {
  /** @nullable */
  data: AccountEntity[] | null;
  /** A descriptive message about the result */
  message: string;
  /** Indicates if the operation was successful */
  status: boolean;
};

/**
 * @nullable
 */
export type AccountInfoEntityUser = UserEntity | null;

export interface AccountInfoEntity {
  accountId: string;
  accountName: string;
  id: number;
  /** @nullable */
  user?: AccountInfoEntityUser;
  userId: number;
}

/**
 * @nullable
 */
export type AccountEntityInfo = AccountInfoEntity | null;

export interface ResetPasswordDto {
  password: string;
  token: string;
}

export interface ForgotPasswordDto {
  /** @maxLength 255 */
  email: string;
}

export interface SimpleMessageEntity {
  /** Message indicating what happened */
  message: string;
  /** Indicates if action happened successfully or not */
  status: boolean;
}

export interface ConfirmEmailDto {
  email: string;
  /** Non-hashed email confirmation token */
  token: string;
}

export interface StopImpersonationDto {
  [key: string]: unknown;
}

export interface ImpersonateUserDto {
  impersonateUserId: number;
}

export interface LoginDto {
  email: string;
  /** @minLength 6 */
  password: string;
}

export interface ResponseErrorEntity {
  /** Error message describing the validation failure */
  message: string;
  /** Indicates whether the request was successful */
  status: boolean;
}

export interface FieldValidationErrors {
  /** List of validation errors for this field */
  errors: string[];
}

/**
 * Detailed validation errors per field
 */
export type ValidationErrorEntityValidationError = {
  [key: string]: FieldValidationErrors;
};

export interface ValidationErrorEntity {
  /** Error message describing the validation failure */
  message: string;
  /** Indicates whether the request was successful */
  status: boolean;
  /** Detailed validation errors per field */
  validationError: ValidationErrorEntityValidationError;
}

export interface SignupDto {
  /** @maxLength 255 */
  email: string;
  /** @maxLength 255 */
  firstName?: string;
  /** @maxLength 255 */
  lastName?: string;
  password: string;
}

export interface UserProfileEntity {
  /** @nullable */
  firstName: string | null;
  id: number;
  /** @nullable */
  lastName: string | null;
  /** @nullable */
  phoneNumber: string | null;
  userId: number;
}

/**
 * @nullable
 */
export type UserEntityProfile = UserProfileEntity | null;

export type Role = (typeof Role)[keyof typeof Role];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Role = {
  Admin: 'Admin',
  User: 'User',
} as const;

export interface UserEntity {
  email: string;
  id: number;
  impersonatedBy?: number;
  isImpersonated?: boolean;
  /** @nullable */
  profile?: UserEntityProfile;
  role: Role;
}

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const signup = (
  signupDto: SignupDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Signup201>(
    {
      url: `/api/auth/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: signupDto,
    },
    options,
  );
};

export const getSignupMutationOptions = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signup>>,
    TError,
    { data: SignupDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signup>>,
  TError,
  { data: SignupDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signup>>,
    { data: SignupDto }
  > = (props) => {
    const { data } = props ?? {};

    return signup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof signup>>
>;
export type SignupMutationBody = SignupDto;
export type SignupMutationError = ValidationErrorEntity | ResponseErrorEntity;

export const useSignup = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signup>>,
    TError,
    { data: SignupDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof signup>>,
  TError,
  { data: SignupDto },
  TContext
> => {
  const mutationOptions = getSignupMutationOptions(options);

  return useMutation(mutationOptions);
};

export const login = (
  loginDto: LoginDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Login200>(
    {
      url: `/api/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginDto,
    },
    options,
  );
};

export const getLoginMutationOptions = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: LoginDto }
  > = (props) => {
    const { data } = props ?? {};

    return login(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = LoginDto;
export type LoginMutationError = ValidationErrorEntity | ResponseErrorEntity;

export const useLogin = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: LoginDto },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

export const impersonateUser = (
  impersonateUserDto: ImpersonateUserDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ImpersonateUser200>(
    {
      url: `/api/auth/impersonate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: impersonateUserDto,
    },
    options,
  );
};

export const getImpersonateUserMutationOptions = <
  TError = ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof impersonateUser>>,
    TError,
    { data: ImpersonateUserDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof impersonateUser>>,
  TError,
  { data: ImpersonateUserDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof impersonateUser>>,
    { data: ImpersonateUserDto }
  > = (props) => {
    const { data } = props ?? {};

    return impersonateUser(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImpersonateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof impersonateUser>>
>;
export type ImpersonateUserMutationBody = ImpersonateUserDto;
export type ImpersonateUserMutationError = ResponseErrorEntity;

export const useImpersonateUser = <
  TError = ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof impersonateUser>>,
    TError,
    { data: ImpersonateUserDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof impersonateUser>>,
  TError,
  { data: ImpersonateUserDto },
  TContext
> => {
  const mutationOptions = getImpersonateUserMutationOptions(options);

  return useMutation(mutationOptions);
};

export const stopImpersonation = (
  stopImpersonationDto: StopImpersonationDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StopImpersonation200>(
    {
      url: `/api/auth/stop-impersonation`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: stopImpersonationDto,
    },
    options,
  );
};

export const getStopImpersonationMutationOptions = <
  TError = ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopImpersonation>>,
    TError,
    { data: StopImpersonationDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stopImpersonation>>,
  TError,
  { data: StopImpersonationDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stopImpersonation>>,
    { data: StopImpersonationDto }
  > = (props) => {
    const { data } = props ?? {};

    return stopImpersonation(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StopImpersonationMutationResult = NonNullable<
  Awaited<ReturnType<typeof stopImpersonation>>
>;
export type StopImpersonationMutationBody = StopImpersonationDto;
export type StopImpersonationMutationError = ResponseErrorEntity;

export const useStopImpersonation = <
  TError = ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stopImpersonation>>,
    TError,
    { data: StopImpersonationDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof stopImpersonation>>,
  TError,
  { data: StopImpersonationDto },
  TContext
> => {
  const mutationOptions = getStopImpersonationMutationOptions(options);

  return useMutation(mutationOptions);
};

export const refreshToken = (
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RefreshToken200>(
    { url: `/api/auth/refresh-token`, method: 'POST' },
    options,
  );
};

export const getRefreshTokenMutationOptions = <
  TError = ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshToken>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshToken>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshToken>>,
    void
  > = () => {
    return refreshToken(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshToken>>
>;

export type RefreshTokenMutationError = ResponseErrorEntity;

export const useRefreshToken = <
  TError = ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshToken>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof refreshToken>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getRefreshTokenMutationOptions(options);

  return useMutation(mutationOptions);
};

export const getProfile = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetProfile200>(
    { url: `/api/auth/profile`, method: 'GET', signal },
    options,
  );
};

export const getGetProfileQueryKey = () => {
  return [`/api/auth/profile`] as const;
};

export const getGetProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ResponseErrorEntity,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProfileQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProfile>>> = ({
    signal,
  }) => getProfile(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProfile>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProfile>>
>;
export type GetProfileQueryError = ResponseErrorEntity;

export const useGetProfile = <
  TData = Awaited<ReturnType<typeof getProfile>>,
  TError = ResponseErrorEntity,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getProfile>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetProfileQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getUserAbilities = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetUserAbilities200>(
    { url: `/api/auth/abilities`, method: 'GET', signal },
    options,
  );
};

export const getGetUserAbilitiesQueryKey = () => {
  return [`/api/auth/abilities`] as const;
};

export const getGetUserAbilitiesQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserAbilities>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUserAbilities>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserAbilitiesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserAbilities>>
  > = ({ signal }) => getUserAbilities(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserAbilities>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserAbilitiesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserAbilities>>
>;
export type GetUserAbilitiesQueryError = unknown;

export const useGetUserAbilities = <
  TData = Awaited<ReturnType<typeof getUserAbilities>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUserAbilities>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserAbilitiesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const logout = (options?: SecondParameter<typeof customInstance>) => {
  return customInstance<unknown>(
    { url: `/api/auth/logout`, method: 'POST' },
    options,
  );
};

export const getLogoutMutationOptions = <
  TError = ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>;

export type LogoutMutationError = ResponseErrorEntity;

export const useLogout = <
  TError = ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions);
};

export const confirmAccount = (
  confirmEmailDto: ConfirmEmailDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ConfirmAccount200>(
    {
      url: `/api/auth/confirm-account`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: confirmEmailDto,
    },
    options,
  );
};

export const getConfirmAccountMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmAccount>>,
    TError,
    { data: ConfirmEmailDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmAccount>>,
  TError,
  { data: ConfirmEmailDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmAccount>>,
    { data: ConfirmEmailDto }
  > = (props) => {
    const { data } = props ?? {};

    return confirmAccount(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmAccountMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmAccount>>
>;
export type ConfirmAccountMutationBody = ConfirmEmailDto;
export type ConfirmAccountMutationError = unknown;

export const useConfirmAccount = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmAccount>>,
    TError,
    { data: ConfirmEmailDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof confirmAccount>>,
  TError,
  { data: ConfirmEmailDto },
  TContext
> => {
  const mutationOptions = getConfirmAccountMutationOptions(options);

  return useMutation(mutationOptions);
};

export const forgotPassword = (
  forgotPasswordDto: ForgotPasswordDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ForgotPassword200>(
    {
      url: `/api/auth/forgot-password`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: forgotPasswordDto,
    },
    options,
  );
};

export const getForgotPasswordMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof forgotPassword>>,
    TError,
    { data: ForgotPasswordDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof forgotPassword>>,
  TError,
  { data: ForgotPasswordDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof forgotPassword>>,
    { data: ForgotPasswordDto }
  > = (props) => {
    const { data } = props ?? {};

    return forgotPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ForgotPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof forgotPassword>>
>;
export type ForgotPasswordMutationBody = ForgotPasswordDto;
export type ForgotPasswordMutationError = unknown;

export const useForgotPassword = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof forgotPassword>>,
    TError,
    { data: ForgotPasswordDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof forgotPassword>>,
  TError,
  { data: ForgotPasswordDto },
  TContext
> => {
  const mutationOptions = getForgotPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

export const resetPassword = (
  resetPasswordDto: ResetPasswordDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ResetPassword200>(
    {
      url: `/api/auth/reset-password`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: resetPasswordDto,
    },
    options,
  );
};

export const getResetPasswordMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetPassword>>,
    TError,
    { data: ResetPasswordDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetPassword>>,
  TError,
  { data: ResetPasswordDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPassword>>,
    { data: ResetPasswordDto }
  > = (props) => {
    const { data } = props ?? {};

    return resetPassword(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetPasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetPassword>>
>;
export type ResetPasswordMutationBody = ResetPasswordDto;
export type ResetPasswordMutationError = unknown;

export const useResetPassword = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetPassword>>,
    TError,
    { data: ResetPasswordDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof resetPassword>>,
  TError,
  { data: ResetPasswordDto },
  TContext
> => {
  const mutationOptions = getResetPasswordMutationOptions(options);

  return useMutation(mutationOptions);
};

export const resendConfirmEmail = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ResendConfirmEmail200>(
    { url: `/api/auth/resend-confirm-email`, method: 'GET', signal },
    options,
  );
};

export const getResendConfirmEmailQueryKey = () => {
  return [`/api/auth/resend-confirm-email`] as const;
};

export const getResendConfirmEmailQueryOptions = <
  TData = Awaited<ReturnType<typeof resendConfirmEmail>>,
  TError = ResponseErrorEntity,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof resendConfirmEmail>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getResendConfirmEmailQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof resendConfirmEmail>>
  > = ({ signal }) => resendConfirmEmail(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof resendConfirmEmail>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ResendConfirmEmailQueryResult = NonNullable<
  Awaited<ReturnType<typeof resendConfirmEmail>>
>;
export type ResendConfirmEmailQueryError = ResponseErrorEntity;

export const useResendConfirmEmail = <
  TData = Awaited<ReturnType<typeof resendConfirmEmail>>,
  TError = ResponseErrorEntity,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof resendConfirmEmail>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getResendConfirmEmailQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const verifyPasswordResetToken = (
  token: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<VerifyPasswordResetToken200>(
    { url: `/api/auth/verify-password-reset/${token}`, method: 'GET', signal },
    options,
  );
};

export const getVerifyPasswordResetTokenQueryKey = (token: string) => {
  return [`/api/auth/verify-password-reset/${token}`] as const;
};

export const getVerifyPasswordResetTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof verifyPasswordResetToken>>,
  TError = unknown,
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof verifyPasswordResetToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getVerifyPasswordResetTokenQueryKey(token);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof verifyPasswordResetToken>>
  > = ({ signal }) => verifyPasswordResetToken(token, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!token,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof verifyPasswordResetToken>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type VerifyPasswordResetTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof verifyPasswordResetToken>>
>;
export type VerifyPasswordResetTokenQueryError = unknown;

export const useVerifyPasswordResetToken = <
  TData = Awaited<ReturnType<typeof verifyPasswordResetToken>>,
  TError = unknown,
>(
  token: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof verifyPasswordResetToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getVerifyPasswordResetTokenQueryOptions(token, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getUserAccounts = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetUserAccounts200>(
    { url: `/api/accounts`, method: 'GET', signal },
    options,
  );
};

export const getGetUserAccountsQueryKey = () => {
  return [`/api/accounts`] as const;
};

export const getGetUserAccountsQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserAccounts>>,
  TError = ResponseErrorEntity,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUserAccounts>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserAccountsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserAccounts>>> = ({
    signal,
  }) => getUserAccounts(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserAccounts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserAccountsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserAccounts>>
>;
export type GetUserAccountsQueryError = ResponseErrorEntity;

export const useGetUserAccounts = <
  TData = Awaited<ReturnType<typeof getUserAccounts>>,
  TError = ResponseErrorEntity,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUserAccounts>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserAccountsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getUserAccountById = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetUserAccountById200>(
    { url: `/api/accounts/${id}`, method: 'GET', signal },
    options,
  );
};

export const getGetUserAccountByIdQueryKey = (id: string) => {
  return [`/api/accounts/${id}`] as const;
};

export const getGetUserAccountByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserAccountById>>,
  TError = ResponseErrorEntity,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAccountById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserAccountByIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserAccountById>>
  > = ({ signal }) => getUserAccountById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserAccountById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUserAccountByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserAccountById>>
>;
export type GetUserAccountByIdQueryError = ResponseErrorEntity;

export const useGetUserAccountById = <
  TData = Awaited<ReturnType<typeof getUserAccountById>>,
  TError = ResponseErrorEntity,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserAccountById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUserAccountByIdQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const fundAccount = (
  id: string,
  fundOrWithdrawFromAccountDto: FundOrWithdrawFromAccountDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<FundAccount200>(
    {
      url: `/api/accounts/${id}/fund-account`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fundOrWithdrawFromAccountDto,
    },
    options,
  );
};

export const getFundAccountMutationOptions = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fundAccount>>,
    TError,
    { id: string; data: FundOrWithdrawFromAccountDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fundAccount>>,
  TError,
  { id: string; data: FundOrWithdrawFromAccountDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fundAccount>>,
    { id: string; data: FundOrWithdrawFromAccountDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return fundAccount(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FundAccountMutationResult = NonNullable<
  Awaited<ReturnType<typeof fundAccount>>
>;
export type FundAccountMutationBody = FundOrWithdrawFromAccountDto;
export type FundAccountMutationError =
  | ValidationErrorEntity
  | ResponseErrorEntity;

export const useFundAccount = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fundAccount>>,
    TError,
    { id: string; data: FundOrWithdrawFromAccountDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof fundAccount>>,
  TError,
  { id: string; data: FundOrWithdrawFromAccountDto },
  TContext
> => {
  const mutationOptions = getFundAccountMutationOptions(options);

  return useMutation(mutationOptions);
};

export const withdrawFromAccount = (
  id: string,
  fundOrWithdrawFromAccountDto: FundOrWithdrawFromAccountDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<unknown>(
    {
      url: `/api/accounts/${id}/withdraw-from-account`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: fundOrWithdrawFromAccountDto,
    },
    options,
  );
};

export const getWithdrawFromAccountMutationOptions = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof withdrawFromAccount>>,
    TError,
    { id: string; data: FundOrWithdrawFromAccountDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof withdrawFromAccount>>,
  TError,
  { id: string; data: FundOrWithdrawFromAccountDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof withdrawFromAccount>>,
    { id: string; data: FundOrWithdrawFromAccountDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return withdrawFromAccount(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WithdrawFromAccountMutationResult = NonNullable<
  Awaited<ReturnType<typeof withdrawFromAccount>>
>;
export type WithdrawFromAccountMutationBody = FundOrWithdrawFromAccountDto;
export type WithdrawFromAccountMutationError =
  | ValidationErrorEntity
  | ResponseErrorEntity;

export const useWithdrawFromAccount = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof withdrawFromAccount>>,
    TError,
    { id: string; data: FundOrWithdrawFromAccountDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof withdrawFromAccount>>,
  TError,
  { id: string; data: FundOrWithdrawFromAccountDto },
  TContext
> => {
  const mutationOptions = getWithdrawFromAccountMutationOptions(options);

  return useMutation(mutationOptions);
};

export const convertFunds = (
  convertFundsDto: ConvertFundsDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ConvertFunds201>(
    {
      url: `/api/transactions/convert-funds`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: convertFundsDto,
    },
    options,
  );
};

export const getConvertFundsMutationOptions = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof convertFunds>>,
    TError,
    { data: ConvertFundsDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof convertFunds>>,
  TError,
  { data: ConvertFundsDto },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof convertFunds>>,
    { data: ConvertFundsDto }
  > = (props) => {
    const { data } = props ?? {};

    return convertFunds(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConvertFundsMutationResult = NonNullable<
  Awaited<ReturnType<typeof convertFunds>>
>;
export type ConvertFundsMutationBody = ConvertFundsDto;
export type ConvertFundsMutationError =
  | ValidationErrorEntity
  | ResponseErrorEntity;

export const useConvertFunds = <
  TError = ValidationErrorEntity | ResponseErrorEntity,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof convertFunds>>,
    TError,
    { data: ConvertFundsDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof convertFunds>>,
  TError,
  { data: ConvertFundsDto },
  TContext
> => {
  const mutationOptions = getConvertFundsMutationOptions(options);

  return useMutation(mutationOptions);
};

export const requeryTransaction = (
  reference: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RequeryTransaction200>(
    { url: `/api/transactions/${reference}/requery`, method: 'GET', signal },
    options,
  );
};

export const getRequeryTransactionQueryKey = (reference: string) => {
  return [`/api/transactions/${reference}/requery`] as const;
};

export const getRequeryTransactionQueryOptions = <
  TData = Awaited<ReturnType<typeof requeryTransaction>>,
  TError = ValidationErrorEntity | ResponseErrorEntity,
>(
  reference: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof requeryTransaction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRequeryTransactionQueryKey(reference);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof requeryTransaction>>
  > = ({ signal }) => requeryTransaction(reference, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!reference,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof requeryTransaction>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type RequeryTransactionQueryResult = NonNullable<
  Awaited<ReturnType<typeof requeryTransaction>>
>;
export type RequeryTransactionQueryError =
  | ValidationErrorEntity
  | ResponseErrorEntity;

export const useRequeryTransaction = <
  TData = Awaited<ReturnType<typeof requeryTransaction>>,
  TError = ValidationErrorEntity | ResponseErrorEntity,
>(
  reference: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof requeryTransaction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRequeryTransactionQueryOptions(reference, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getManyTransactions = (
  params?: GetManyTransactionsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetManyTransactions200>(
    { url: `/api/transactions`, method: 'GET', params, signal },
    options,
  );
};

export const getGetManyTransactionsQueryKey = (
  params?: GetManyTransactionsParams,
) => {
  return [`/api/transactions`, ...(params ? [params] : [])] as const;
};

export const getGetManyTransactionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getManyTransactions>>,
  TError = unknown,
>(
  params?: GetManyTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getManyTransactions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetManyTransactionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getManyTransactions>>
  > = ({ signal }) => getManyTransactions(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getManyTransactions>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetManyTransactionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getManyTransactions>>
>;
export type GetManyTransactionsQueryError = unknown;

export const useGetManyTransactions = <
  TData = Awaited<ReturnType<typeof getManyTransactions>>,
  TError = unknown,
>(
  params?: GetManyTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getManyTransactions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetManyTransactionsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getDashboardData = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetDashboardData200>(
    { url: `/api/dashboard`, method: 'GET', signal },
    options,
  );
};

export const getGetDashboardDataQueryKey = () => {
  return [`/api/dashboard`] as const;
};

export const getGetDashboardDataQueryOptions = <
  TData = Awaited<ReturnType<typeof getDashboardData>>,
  TError = ResponseErrorEntity,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getDashboardData>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDashboardDataQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDashboardData>>
  > = ({ signal }) => getDashboardData(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardData>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDashboardDataQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardData>>
>;
export type GetDashboardDataQueryError = ResponseErrorEntity;

export const useGetDashboardData = <
  TData = Awaited<ReturnType<typeof getDashboardData>>,
  TError = ResponseErrorEntity,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getDashboardData>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetDashboardDataQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getSignupResponseMock = (
  overrideResponse: Partial<Signup201> = {},
): Signup201 => ({
  data: {
    email: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    impersonatedBy: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    isImpersonated: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      undefined,
    ]),
    profile: faker.helpers.arrayElement([
      {
        firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
        id: faker.number.int({ min: undefined, max: undefined }),
        lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
        phoneNumber: faker.helpers.arrayElement([faker.word.sample(), null]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    role: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(Role)),
    ]),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getLoginResponseMock = (
  overrideResponse: Partial<Login200> = {},
): Login200 => ({
  data: {
    email: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    impersonatedBy: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    isImpersonated: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      undefined,
    ]),
    profile: faker.helpers.arrayElement([
      {
        firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
        id: faker.number.int({ min: undefined, max: undefined }),
        lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
        phoneNumber: faker.helpers.arrayElement([faker.word.sample(), null]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    role: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(Role)),
    ]),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getImpersonateUserResponseMock = (
  overrideResponse: Partial<ImpersonateUser200> = {},
): ImpersonateUser200 => ({
  data: {
    email: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    impersonatedBy: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    isImpersonated: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      undefined,
    ]),
    profile: faker.helpers.arrayElement([
      {
        firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
        id: faker.number.int({ min: undefined, max: undefined }),
        lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
        phoneNumber: faker.helpers.arrayElement([faker.word.sample(), null]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    role: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(Role)),
    ]),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getStopImpersonationResponseMock = (
  overrideResponse: Partial<StopImpersonation200> = {},
): StopImpersonation200 => ({
  data: {
    email: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    impersonatedBy: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    isImpersonated: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      undefined,
    ]),
    profile: faker.helpers.arrayElement([
      {
        firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
        id: faker.number.int({ min: undefined, max: undefined }),
        lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
        phoneNumber: faker.helpers.arrayElement([faker.word.sample(), null]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    role: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(Role)),
    ]),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getRefreshTokenResponseMock = (
  overrideResponse: Partial<RefreshToken200> = {},
): RefreshToken200 => ({
  data: {
    email: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    impersonatedBy: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    isImpersonated: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      undefined,
    ]),
    profile: faker.helpers.arrayElement([
      {
        firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
        id: faker.number.int({ min: undefined, max: undefined }),
        lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
        phoneNumber: faker.helpers.arrayElement([faker.word.sample(), null]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    role: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(Role)),
    ]),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGetProfileResponseMock = (
  overrideResponse: Partial<GetProfile200> = {},
): GetProfile200 => ({
  data: {
    email: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    impersonatedBy: faker.helpers.arrayElement([
      faker.number.int({ min: undefined, max: undefined }),
      undefined,
    ]),
    isImpersonated: faker.helpers.arrayElement([
      faker.datatype.boolean(),
      undefined,
    ]),
    profile: faker.helpers.arrayElement([
      {
        firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
        id: faker.number.int({ min: undefined, max: undefined }),
        lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
        phoneNumber: faker.helpers.arrayElement([faker.word.sample(), null]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    role: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(Role)),
    ]),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGetUserAbilitiesResponseMock = (
  overrideResponse: Partial<GetUserAbilities200> = {},
): GetUserAbilities200 => ({
  data: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => faker.word.sample()),
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getConfirmAccountResponseMock = (
  overrideResponse: Partial<ConfirmAccount200> = {},
): ConfirmAccount200 => ({
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getForgotPasswordResponseMock = (
  overrideResponse: Partial<ForgotPassword200> = {},
): ForgotPassword200 => ({
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getResetPasswordResponseMock = (
  overrideResponse: Partial<ResetPassword200> = {},
): ResetPassword200 => ({
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getResendConfirmEmailResponseMock = (
  overrideResponse: Partial<ResendConfirmEmail200> = {},
): ResendConfirmEmail200 => ({
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getVerifyPasswordResetTokenResponseMock = (
  overrideResponse: Partial<VerifyPasswordResetToken200> = {},
): VerifyPasswordResetToken200 => ({
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGetUserAccountsResponseMock = (
  overrideResponse: Partial<GetUserAccounts200> = {},
): GetUserAccounts200 => ({
  data: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    availableBalance: faker.word.sample(),
    currencyCode: faker.word.sample(),
    currencyName: faker.word.sample(),
    currencySymbol: faker.word.sample(),
    id: faker.word.sample(),
    info: faker.helpers.arrayElement([
      {
        accountId: faker.word.sample(),
        accountName: faker.word.sample(),
        id: faker.number.int({ min: undefined, max: undefined }),
        user: faker.helpers.arrayElement([
          {
            email: faker.word.sample(),
            id: faker.number.int({ min: undefined, max: undefined }),
            impersonatedBy: faker.helpers.arrayElement([
              faker.number.int({ min: undefined, max: undefined }),
              undefined,
            ]),
            isImpersonated: faker.helpers.arrayElement([
              faker.datatype.boolean(),
              undefined,
            ]),
            profile: faker.helpers.arrayElement([
              {
                firstName: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                id: faker.number.int({ min: undefined, max: undefined }),
                lastName: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                phoneNumber: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                userId: faker.number.int({ min: undefined, max: undefined }),
              },
              undefined,
            ]),
            role: faker.helpers.arrayElement([
              faker.helpers.arrayElement(Object.values(Role)),
            ]),
          },
          undefined,
        ]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    pendingBalance: faker.word.sample(),
    user: faker.helpers.arrayElement([
      {
        email: faker.word.sample(),
        id: faker.number.int({ min: undefined, max: undefined }),
        impersonatedBy: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        isImpersonated: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          undefined,
        ]),
        profile: faker.helpers.arrayElement([
          {
            firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
            id: faker.number.int({ min: undefined, max: undefined }),
            lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
            phoneNumber: faker.helpers.arrayElement([
              faker.word.sample(),
              null,
            ]),
            userId: faker.number.int({ min: undefined, max: undefined }),
          },
          undefined,
        ]),
        role: faker.helpers.arrayElement([
          faker.helpers.arrayElement(Object.values(Role)),
        ]),
      },
      undefined,
    ]),
    userId: faker.number.int({ min: undefined, max: undefined }),
  })),
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGetUserAccountByIdResponseMock = (
  overrideResponse: Partial<GetUserAccountById200> = {},
): GetUserAccountById200 => ({
  data: {
    availableBalance: faker.word.sample(),
    currencyCode: faker.word.sample(),
    currencyName: faker.word.sample(),
    currencySymbol: faker.word.sample(),
    id: faker.word.sample(),
    info: faker.helpers.arrayElement([
      {
        accountId: faker.word.sample(),
        accountName: faker.word.sample(),
        id: faker.number.int({ min: undefined, max: undefined }),
        user: faker.helpers.arrayElement([
          {
            email: faker.word.sample(),
            id: faker.number.int({ min: undefined, max: undefined }),
            impersonatedBy: faker.helpers.arrayElement([
              faker.number.int({ min: undefined, max: undefined }),
              undefined,
            ]),
            isImpersonated: faker.helpers.arrayElement([
              faker.datatype.boolean(),
              undefined,
            ]),
            profile: faker.helpers.arrayElement([
              {
                firstName: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                id: faker.number.int({ min: undefined, max: undefined }),
                lastName: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                phoneNumber: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                userId: faker.number.int({ min: undefined, max: undefined }),
              },
              undefined,
            ]),
            role: faker.helpers.arrayElement([
              faker.helpers.arrayElement(Object.values(Role)),
            ]),
          },
          undefined,
        ]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    pendingBalance: faker.word.sample(),
    user: faker.helpers.arrayElement([
      {
        email: faker.word.sample(),
        id: faker.number.int({ min: undefined, max: undefined }),
        impersonatedBy: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        isImpersonated: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          undefined,
        ]),
        profile: faker.helpers.arrayElement([
          {
            firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
            id: faker.number.int({ min: undefined, max: undefined }),
            lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
            phoneNumber: faker.helpers.arrayElement([
              faker.word.sample(),
              null,
            ]),
            userId: faker.number.int({ min: undefined, max: undefined }),
          },
          undefined,
        ]),
        role: faker.helpers.arrayElement([
          faker.helpers.arrayElement(Object.values(Role)),
        ]),
      },
      undefined,
    ]),
    userId: faker.number.int({ min: undefined, max: undefined }),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getFundAccountResponseMock = (
  overrideResponse: Partial<FundAccount200> = {},
): FundAccount200 => ({
  data: {
    availableBalance: faker.word.sample(),
    currencyCode: faker.word.sample(),
    currencyName: faker.word.sample(),
    currencySymbol: faker.word.sample(),
    id: faker.word.sample(),
    info: faker.helpers.arrayElement([
      {
        accountId: faker.word.sample(),
        accountName: faker.word.sample(),
        id: faker.number.int({ min: undefined, max: undefined }),
        user: faker.helpers.arrayElement([
          {
            email: faker.word.sample(),
            id: faker.number.int({ min: undefined, max: undefined }),
            impersonatedBy: faker.helpers.arrayElement([
              faker.number.int({ min: undefined, max: undefined }),
              undefined,
            ]),
            isImpersonated: faker.helpers.arrayElement([
              faker.datatype.boolean(),
              undefined,
            ]),
            profile: faker.helpers.arrayElement([
              {
                firstName: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                id: faker.number.int({ min: undefined, max: undefined }),
                lastName: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                phoneNumber: faker.helpers.arrayElement([
                  faker.word.sample(),
                  null,
                ]),
                userId: faker.number.int({ min: undefined, max: undefined }),
              },
              undefined,
            ]),
            role: faker.helpers.arrayElement([
              faker.helpers.arrayElement(Object.values(Role)),
            ]),
          },
          undefined,
        ]),
        userId: faker.number.int({ min: undefined, max: undefined }),
      },
      undefined,
    ]),
    pendingBalance: faker.word.sample(),
    user: faker.helpers.arrayElement([
      {
        email: faker.word.sample(),
        id: faker.number.int({ min: undefined, max: undefined }),
        impersonatedBy: faker.helpers.arrayElement([
          faker.number.int({ min: undefined, max: undefined }),
          undefined,
        ]),
        isImpersonated: faker.helpers.arrayElement([
          faker.datatype.boolean(),
          undefined,
        ]),
        profile: faker.helpers.arrayElement([
          {
            firstName: faker.helpers.arrayElement([faker.word.sample(), null]),
            id: faker.number.int({ min: undefined, max: undefined }),
            lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
            phoneNumber: faker.helpers.arrayElement([
              faker.word.sample(),
              null,
            ]),
            userId: faker.number.int({ min: undefined, max: undefined }),
          },
          undefined,
        ]),
        role: faker.helpers.arrayElement([
          faker.helpers.arrayElement(Object.values(Role)),
        ]),
      },
      undefined,
    ]),
    userId: faker.number.int({ min: undefined, max: undefined }),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getConvertFundsResponseMock = (
  overrideResponse: Partial<ConvertFunds201> = {},
): ConvertFunds201 => ({
  data: {
    conversionRate: faker.word.sample(),
    convertedAmount: faker.word.sample(),
    createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    fromAccountId: faker.word.sample(),
    fromCurrency: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    originalAmount: faker.word.sample(),
    reference: faker.word.sample(),
    status: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(TransactionStatus)),
    ]),
    toAccountId: faker.word.sample(),
    toCurrency: faker.word.sample(),
    updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    userId: faker.number.int({ min: undefined, max: undefined }),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getRequeryTransactionResponseMock = (
  overrideResponse: Partial<RequeryTransaction200> = {},
): RequeryTransaction200 => ({
  data: {
    conversionRate: faker.word.sample(),
    convertedAmount: faker.word.sample(),
    createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    fromAccountId: faker.word.sample(),
    fromCurrency: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    originalAmount: faker.word.sample(),
    reference: faker.word.sample(),
    status: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(TransactionStatus)),
    ]),
    toAccountId: faker.word.sample(),
    toCurrency: faker.word.sample(),
    updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    userId: faker.number.int({ min: undefined, max: undefined }),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGetManyTransactionsResponseMock = (
  overrideResponse: Partial<GetManyTransactions200> = {},
): GetManyTransactions200 => ({
  data: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    conversionRate: faker.word.sample(),
    convertedAmount: faker.word.sample(),
    createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    fromAccountId: faker.word.sample(),
    fromCurrency: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    originalAmount: faker.word.sample(),
    reference: faker.word.sample(),
    status: faker.helpers.arrayElement([
      faker.helpers.arrayElement(Object.values(TransactionStatus)),
    ]),
    toAccountId: faker.word.sample(),
    toCurrency: faker.word.sample(),
    updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    userId: faker.number.int({ min: undefined, max: undefined }),
  })),
  message: faker.word.sample(),
  meta: faker.helpers.arrayElement([
    {
      currentPage: faker.number.int({ min: undefined, max: undefined }),
      lastPage: faker.number.int({ min: undefined, max: undefined }),
      next: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        null,
      ]),
      perPage: faker.number.int({ min: undefined, max: undefined }),
      prev: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        null,
      ]),
      total: faker.number.int({ min: undefined, max: undefined }),
    },
    undefined,
  ]),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getGetDashboardDataResponseMock = (
  overrideResponse: Partial<GetDashboardData200> = {},
): GetDashboardData200 => ({
  data: {
    balances: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      availableBalance: faker.word.sample(),
      currencyCode: faker.word.sample(),
      currencyName: faker.word.sample(),
      currencySymbol: faker.word.sample(),
      id: faker.word.sample(),
      info: faker.helpers.arrayElement([
        {
          accountId: faker.word.sample(),
          accountName: faker.word.sample(),
          id: faker.number.int({ min: undefined, max: undefined }),
          user: faker.helpers.arrayElement([
            {
              email: faker.word.sample(),
              id: faker.number.int({ min: undefined, max: undefined }),
              impersonatedBy: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined,
              ]),
              isImpersonated: faker.helpers.arrayElement([
                faker.datatype.boolean(),
                undefined,
              ]),
              profile: faker.helpers.arrayElement([
                {
                  firstName: faker.helpers.arrayElement([
                    faker.word.sample(),
                    null,
                  ]),
                  id: faker.number.int({ min: undefined, max: undefined }),
                  lastName: faker.helpers.arrayElement([
                    faker.word.sample(),
                    null,
                  ]),
                  phoneNumber: faker.helpers.arrayElement([
                    faker.word.sample(),
                    null,
                  ]),
                  userId: faker.number.int({ min: undefined, max: undefined }),
                },
                undefined,
              ]),
              role: faker.helpers.arrayElement([
                faker.helpers.arrayElement(Object.values(Role)),
              ]),
            },
            undefined,
          ]),
          userId: faker.number.int({ min: undefined, max: undefined }),
        },
        undefined,
      ]),
      pendingBalance: faker.word.sample(),
      user: faker.helpers.arrayElement([
        {
          email: faker.word.sample(),
          id: faker.number.int({ min: undefined, max: undefined }),
          impersonatedBy: faker.helpers.arrayElement([
            faker.number.int({ min: undefined, max: undefined }),
            undefined,
          ]),
          isImpersonated: faker.helpers.arrayElement([
            faker.datatype.boolean(),
            undefined,
          ]),
          profile: faker.helpers.arrayElement([
            {
              firstName: faker.helpers.arrayElement([
                faker.word.sample(),
                null,
              ]),
              id: faker.number.int({ min: undefined, max: undefined }),
              lastName: faker.helpers.arrayElement([faker.word.sample(), null]),
              phoneNumber: faker.helpers.arrayElement([
                faker.word.sample(),
                null,
              ]),
              userId: faker.number.int({ min: undefined, max: undefined }),
            },
            undefined,
          ]),
          role: faker.helpers.arrayElement([
            faker.helpers.arrayElement(Object.values(Role)),
          ]),
        },
        undefined,
      ]),
      userId: faker.number.int({ min: undefined, max: undefined }),
    })),
    recentTransactions: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      conversionRate: faker.word.sample(),
      convertedAmount: faker.word.sample(),
      createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
      fromAccountId: faker.word.sample(),
      fromCurrency: faker.word.sample(),
      id: faker.number.int({ min: undefined, max: undefined }),
      originalAmount: faker.word.sample(),
      reference: faker.word.sample(),
      status: faker.helpers.arrayElement([
        faker.helpers.arrayElement(Object.values(TransactionStatus)),
      ]),
      toAccountId: faker.word.sample(),
      toCurrency: faker.word.sample(),
      updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
      userId: faker.number.int({ min: undefined, max: undefined }),
    })),
  },
  message: faker.word.sample(),
  status: faker.datatype.boolean(),
  ...overrideResponse,
});

export const getSignupMockHandler = (
  overrideResponse?:
    | Signup201
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Signup201> | Signup201),
) => {
  return http.post('*/api/auth/signup', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getSignupResponseMock(),
      ),
      {
        status: 201,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getLoginMockHandler = (
  overrideResponse?:
    | Login200
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<Login200> | Login200),
) => {
  return http.post('*/api/auth/login', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getLoginResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getImpersonateUserMockHandler = (
  overrideResponse?:
    | ImpersonateUser200
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<ImpersonateUser200> | ImpersonateUser200),
) => {
  return http.post('*/api/auth/impersonate', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getImpersonateUserResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getStopImpersonationMockHandler = (
  overrideResponse?:
    | StopImpersonation200
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<StopImpersonation200> | StopImpersonation200),
) => {
  return http.post('*/api/auth/stop-impersonation', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getStopImpersonationResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getRefreshTokenMockHandler = (
  overrideResponse?:
    | RefreshToken200
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<RefreshToken200> | RefreshToken200),
) => {
  return http.post('*/api/auth/refresh-token', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getRefreshTokenResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetProfileMockHandler = (
  overrideResponse?:
    | GetProfile200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetProfile200> | GetProfile200),
) => {
  return http.get('*/api/auth/profile', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetProfileResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetUserAbilitiesMockHandler = (
  overrideResponse?:
    | GetUserAbilities200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetUserAbilities200> | GetUserAbilities200),
) => {
  return http.get('*/api/auth/abilities', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUserAbilitiesResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getLogoutMockHandler = () => {
  return http.post('*/api/auth/logout', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 204,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getConfirmAccountMockHandler = (
  overrideResponse?:
    | ConfirmAccount200
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<ConfirmAccount200> | ConfirmAccount200),
) => {
  return http.put('*/api/auth/confirm-account', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getConfirmAccountResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getForgotPasswordMockHandler = (
  overrideResponse?:
    | ForgotPassword200
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<ForgotPassword200> | ForgotPassword200),
) => {
  return http.put('*/api/auth/forgot-password', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getForgotPasswordResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getResetPasswordMockHandler = (
  overrideResponse?:
    | ResetPassword200
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<ResetPassword200> | ResetPassword200),
) => {
  return http.put('*/api/auth/reset-password', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getResetPasswordResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getResendConfirmEmailMockHandler = (
  overrideResponse?:
    | ResendConfirmEmail200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<ResendConfirmEmail200> | ResendConfirmEmail200),
) => {
  return http.get('*/api/auth/resend-confirm-email', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getResendConfirmEmailResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getVerifyPasswordResetTokenMockHandler = (
  overrideResponse?:
    | VerifyPasswordResetToken200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<VerifyPasswordResetToken200> | VerifyPasswordResetToken200),
) => {
  return http.get('*/api/auth/verify-password-reset/:token', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getVerifyPasswordResetTokenResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetUserAccountsMockHandler = (
  overrideResponse?:
    | GetUserAccounts200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetUserAccounts200> | GetUserAccounts200),
) => {
  return http.get('*/api/accounts', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUserAccountsResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetUserAccountByIdMockHandler = (
  overrideResponse?:
    | GetUserAccountById200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetUserAccountById200> | GetUserAccountById200),
) => {
  return http.get('*/api/accounts/:id', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUserAccountByIdResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getFundAccountMockHandler = (
  overrideResponse?:
    | FundAccount200
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<FundAccount200> | FundAccount200),
) => {
  return http.post('*/api/accounts/:id/fund-account', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getFundAccountResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getWithdrawFromAccountMockHandler = () => {
  return http.post('*/api/accounts/:id/withdraw-from-account', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getConvertFundsMockHandler = (
  overrideResponse?:
    | ConvertFunds201
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<ConvertFunds201> | ConvertFunds201),
) => {
  return http.post('*/api/transactions/convert-funds', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getConvertFundsResponseMock(),
      ),
      {
        status: 201,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getRequeryTransactionMockHandler = (
  overrideResponse?:
    | RequeryTransaction200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<RequeryTransaction200> | RequeryTransaction200),
) => {
  return http.get('*/api/transactions/:reference/requery', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getRequeryTransactionResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetManyTransactionsMockHandler = (
  overrideResponse?:
    | GetManyTransactions200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetManyTransactions200> | GetManyTransactions200),
) => {
  return http.get('*/api/transactions', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetManyTransactionsResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetDashboardDataMockHandler = (
  overrideResponse?:
    | GetDashboardData200
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<GetDashboardData200> | GetDashboardData200),
) => {
  return http.get('*/api/dashboard', async (info) => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getGetDashboardDataResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};
export const getFincraConverterMock = () => [
  getSignupMockHandler(),
  getLoginMockHandler(),
  getImpersonateUserMockHandler(),
  getStopImpersonationMockHandler(),
  getRefreshTokenMockHandler(),
  getGetProfileMockHandler(),
  getGetUserAbilitiesMockHandler(),
  getLogoutMockHandler(),
  getConfirmAccountMockHandler(),
  getForgotPasswordMockHandler(),
  getResetPasswordMockHandler(),
  getResendConfirmEmailMockHandler(),
  getVerifyPasswordResetTokenMockHandler(),
  getGetUserAccountsMockHandler(),
  getGetUserAccountByIdMockHandler(),
  getFundAccountMockHandler(),
  getWithdrawFromAccountMockHandler(),
  getConvertFundsMockHandler(),
  getRequeryTransactionMockHandler(),
  getGetManyTransactionsMockHandler(),
  getGetDashboardDataMockHandler(),
];
